// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using nanoFramework.TestFramework.Tools;

namespace nanoFramework.TestFramework.Tooling
{
    /// <summary>
    /// The parser receives the output from the code generated by the
    /// <see cref="UnitTestLauncherGenerator"/> and produces a <see cref="TestResult"/>
    /// for each test case in the selection.
    /// </summary>
    public sealed class UnitTestsOutputParser
    {
        #region Fields
        private readonly TestCaseSelection _testCases;
        private readonly string _reportPrefix;
        private readonly string _comPort;
        private readonly Action<IEnumerable<TestResult>> _testResultSink;
        private readonly Action _parsingAborted;
        private readonly CancellationToken? _cancellationToken;
        private readonly HashSet<TestCase> _resultsSent = new HashSet<TestCase>();
        private string _lineToBeProcessed = null;
        private List<string> _currentOutput = null;
        private enum TestClassPhases
        {
            NotStarted,
            NoMansLand,
            TestClassFound,
            Instantiate,
            Setup,
            Tests,
            Cleanup,
            Dispose,
            Done,
            Abort
        }
        private TestClassPhases _testClassPhase;
        private readonly List<string> _deploymentInformation = new List<string>();
        private TestCaseGroup _currentGroup;
        private readonly List<string> _groupSetupOutput = new List<string>();
        private TestResult.TestOutcome _groupSetupOutcome = TestResult.TestOutcome.Passed;
        private TestCase _currentTestCase;
        private readonly Dictionary<TestCase, TestResult> _testsInGroup = new Dictionary<TestCase, TestResult>();
        private readonly List<string> _groupCleanupOutput = new List<string>();
        private TestResult.TestOutcome _groupCleanupOutcome = TestResult.TestOutcome.Passed;
        #endregion

        #region Construction
        /// <summary>
        /// Create the parser
        /// </summary>
        /// <param name="testCases">The selection of test cases being run</param>
        /// <param name="comPort">In case the test is run on real hardware: the COM-port
        /// of the device the test is executed on.</param>
        /// <param name="reportPrefix">The prefix used in the tests to mark messages
        /// from the unit test launcher.</param>
        /// <param name="testResultSink">Method that will receive the test results</param>
        public UnitTestsOutputParser(TestCaseSelection testCases, string comPort, string reportPrefix, Action<IEnumerable<TestResult>> testResultSink)
            : this(testCases, comPort, reportPrefix, testResultSink, null, null)
        {
        }

        /// <summary>
        /// Create the parser
        /// </summary>
        /// <param name="testCases">The selection of test cases being run</param>
        /// <param name="comPort">In case the test is run on real hardware: the COM-port
        /// of the device the test is executed on.</param>
        /// <param name="reportPrefix">The prefix used in the tests to mark messages
        /// from the unit test launcher.</param>
        /// <param name="testResultSink">Method that will receive the test results</param>
        /// <param name="parsingAborted">Method called when the parsing of output has been aborted in response to cancellation of <paramref name="cancellationToken"/>.</param>
        /// <param name="cancellationToken">Cancellation token that indicates whether the execution of tests should be aborted (gracefully).</param>
        public UnitTestsOutputParser(TestCaseSelection testCases, string comPort, string reportPrefix, Action<IEnumerable<TestResult>> testResultSink, Action parsingAborted, CancellationToken? cancellationToken)
        {
            _testCases = testCases;
            _comPort = comPort;
            _reportPrefix = reportPrefix;
            _testResultSink = testResultSink;
            _currentOutput = _deploymentInformation;
            _parsingAborted = parsingAborted;
            _cancellationToken = cancellationToken;
            _testClassPhase = TestClassPhases.NotStarted;
        }
        #endregion

        #region Methods
        /// <summary>
        /// Pass a piece of the output to the parser. The caller does not have to wait
        /// for the method to complete.
        /// </summary>
        /// <param name="output">The output of the unit tests</param>
        public void AddOutput(string output)
        {
            lock (this)
            {
                if (_testClassPhase == TestClassPhases.Abort)
                {
                    return;
                }
                if (!(_lineToBeProcessed is null))
                {
                    output = _lineToBeProcessed + output;
                    _lineToBeProcessed = null;
                }
                ParseOutput(output);
            }
        }

        /// <summary>
        /// All tests have been completed. Make sure all test results have been sent.
        /// </summary>
        /// <param name="deviceExecutionIsAbortedReason">If the device has prematurely stopped running the unit tests,
        /// e.g., because the maximum time has been exceeded, this is a description to be added to the tests for which
        /// no results have been obtained.</param>
        public void Flush(string deviceExecutionIsAbortedReason = null)
        {
            lock (this)
            {
                if (!(_lineToBeProcessed is null))
                {
                    ParseOutput(_lineToBeProcessed + '\n');
                }

                if (!string.IsNullOrWhiteSpace(deviceExecutionIsAbortedReason)
                    || (_testClassPhase == TestClassPhases.NotStarted && _deploymentInformation.Count > 0))
                {
                    SendNotExecutedResults(deviceExecutionIsAbortedReason);
                }
                else
                {
                    SendGroupResults(true);
                }
            }
        }
        #endregion

        #region Implementation
        /// <summary>
        /// Pass a piece of the output to the parser. The caller does not have to wait
        /// for the method to complete.
        /// </summary>
        /// <param name="output">The output of the unit tests</param>
        private void ParseOutput(string output)
        {
            foreach (Match match in _parseOutput.Matches(output))
            {
                if (match.Groups["empty"].Success)
                {
                    _currentOutput?.Add("");
                }
                else if (match.Groups["output"].Success)
                {
                    _currentOutput?.Add(match.Groups["output"].Value);
                }
                else if (match.Groups["incomplete"].Success)
                {
                    // Must be the last line of the output
                    _lineToBeProcessed = match.Groups["incomplete"].Value;
                }
                else if (match.Groups["prefix"].Value != _reportPrefix)
                {
                    // A unit test is trying to impersonate the unit test launcher!
                    _currentOutput?.Add(match.Value.Replace("\r", "").Replace("\r", ""));
                }
                else
                {
                    UnitTestLauncher.Communication communication;
                    if (int.TryParse(match.Groups["com"].Value, out int comValue))
                    {
                        // It is more readable to use the names of the enums. But on nanoCRL the default
                        // for a string representation of an enum value is a number. That is more compact.
                        // Support reading both types of output.
                        communication = (UnitTestLauncher.Communication)comValue;
                    }
                    else if (!Enum.TryParse(match.Groups["com"].Value, out communication))
                    {
                        // This should not happen; software on device should be generated by this library
                        // Nothing else to do that to ignore it.
                        continue;
                    }

                    if (match.Groups["type"].Value == "C")
                    {
                        #region Messages at the test class level
                        string fqn = match.Groups["fqn"].Value;

                        if (_currentGroup is null || _currentGroup.FullyQualifiedName != fqn)
                        {
                            SendGroupResults();
                            if (IsAbortRequested())
                            {
                                return;
                            }

                            _currentGroup = (from tc in _testCases.TestCases
                                             where tc.testCase.Group.FullyQualifiedName == fqn
                                             select tc.testCase.Group).FirstOrDefault();
                            _testClassPhase = _currentGroup is null
                                ? TestClassPhases.NoMansLand
                                : TestClassPhases.TestClassFound;
                            _currentOutput = null;
                        }
                        #endregion

                        if (_testClassPhase != TestClassPhases.NoMansLand)
                        {
                            switch (communication)
                            {
                                #region Setup
                                case UnitTestLauncher.Communication.Start:
                                    _testClassPhase = TestClassPhases.TestClassFound;
                                    _currentOutput = _groupSetupOutput;
                                    break;

                                case UnitTestLauncher.Communication.Instantiate:
                                    _testClassPhase = TestClassPhases.Instantiate;
                                    _currentOutput = _groupSetupOutput;
                                    break;

                                case UnitTestLauncher.Communication.Setup:
                                    _testClassPhase = TestClassPhases.Setup;
                                    _currentOutput = _groupSetupOutput;
                                    _currentOutput.Add($"Setup method '{match.Groups["msg"]?.Value?.Trim()}' started{ElapsedTime(match)}");
                                    break;

                                case UnitTestLauncher.Communication.SetupFail:
                                    _currentOutput = _groupSetupOutput;
                                    if (_testClassPhase == TestClassPhases.Instantiate)
                                    {
                                        AddFailDescription(match, $"Constructor of test class failed{ElapsedTime(match)}");
                                    }
                                    else
                                    {
                                        AddFailDescription(match, $"Execution of setup method failed{ElapsedTime(match)}");
                                    }
                                    _groupSetupOutcome = TestResult.TestOutcome.Failed;
                                    SendGroupResults();
                                    break;

                                case UnitTestLauncher.Communication.SetupComplete:
                                    _testClassPhase = TestClassPhases.Tests;
                                    _currentOutput?.Add($"Setup completed{ElapsedTime(match)}");
                                    _currentOutput = null;
                                    break;
                                #endregion

                                #region Cleanup
                                case UnitTestLauncher.Communication.Cleanup:
                                    _testClassPhase = TestClassPhases.Cleanup;
                                    _currentOutput = _groupCleanupOutput;
                                    _currentOutput.Add($"Cleanup method '{match.Groups["msg"]?.Value?.Trim()}' started{ElapsedTime(match)}");
                                    break;

                                case UnitTestLauncher.Communication.Dispose:
                                    _testClassPhase = TestClassPhases.Dispose;
                                    _currentOutput = _groupCleanupOutput;
                                    break;

                                case UnitTestLauncher.Communication.CleanupFail:
                                    _currentOutput = _groupCleanupOutput;
                                    if (_testClassPhase == TestClassPhases.Dispose)
                                    {
                                        AddFailDescription(match, $"{nameof(IDisposable)}.{nameof(IDisposable.Dispose)} of test class failed{ElapsedTime(match)}");
                                    }
                                    else
                                    {
                                        AddFailDescription(match, $"Execution of cleanup method failed{ElapsedTime(match)}");
                                    }
                                    _groupCleanupOutcome = TestResult.TestOutcome.Failed;
                                    SendGroupResults();
                                    break;

                                case UnitTestLauncher.Communication.CleanUpComplete:
                                    _testClassPhase = TestClassPhases.Done;
                                    _currentOutput?.Add($"Cleanup completed{ElapsedTime(match)}");
                                    SendGroupResults();
                                    break;
                                #endregion

                                #region Shared setup / cleanup
                                case UnitTestLauncher.Communication.MethodError:
                                    if (_testClassPhase < TestClassPhases.Tests)
                                    {
                                        _groupSetupOutcome = TestResult.TestOutcome.Failed;
                                        _currentOutput = _groupSetupOutput;
                                    }
                                    else
                                    {
                                        _groupCleanupOutcome = TestResult.TestOutcome.Failed;
                                        _currentOutput = _groupCleanupOutput;
                                    }
                                    AddFailDescription(match, null);
                                    SendGroupResults();
                                    break;
                                #endregion

                                case UnitTestLauncher.Communication.Done:
                                    SendGroupResults();
                                    break;
                            }
                        }
                    }
                    else if (_testClassPhase != TestClassPhases.NoMansLand)
                    {
                        #region Messages about a test method or data row
                        string fqn = match.Groups["fqn"].Value;
                        int dataRowIndex = match.Groups["type"].Value == "M"
                            ? -1
                            : int.Parse(match.Groups["row"].Value);

                        if (_currentTestCase is null
                            || _currentTestCase.FullyQualifiedName != fqn
                            || _currentTestCase.DataRowIndex != dataRowIndex)
                        {
                            (int selectionIndex, TestCase testCase) = (from tc in _testCases.TestCases
                                                                       where tc.testCase.FullyQualifiedName == fqn && tc.testCase.DataRowIndex == dataRowIndex
                                                                       select tc).FirstOrDefault();
                            _currentTestCase = testCase;
                            if (_currentTestCase is null)
                            {
                                _currentOutput = null;
                            }
                            else
                            {
                                if (!_testsInGroup.TryGetValue(_currentTestCase, out TestResult testResult))
                                {
                                    _testsInGroup[_currentTestCase] = testResult = new TestResult(_currentTestCase, selectionIndex, _comPort);
                                }
                                _currentOutput = testResult._messages;
                            }
                            _testClassPhase = TestClassPhases.Tests;
                        }
                        #endregion

                        if (!(_currentTestCase is null))
                        {
                            #region Test execution
                            switch (communication)
                            {
                                case UnitTestLauncher.Communication.MethodError:
                                    AddFailDescription(match, null);
                                    SetTestOutcome(match, TestResult.TestOutcome.Failed, "Method not found");
                                    break;

                                case UnitTestLauncher.Communication.Skipped:
                                    AddFailDescription(match, $"Execution of the test is aborted{ElapsedTime(match)}");
                                    SetTestOutcome(match, TestResult.TestOutcome.Skipped, "Test skipped");
                                    break;

                                case UnitTestLauncher.Communication.SetupFail:
                                    AddFailDescription(match, $"Setup for the test failed{ElapsedTime(match)}");
                                    SetTestOutcome(match, TestResult.TestOutcome.Failed, "Setup failed");
                                    break;

                                case UnitTestLauncher.Communication.SetupComplete:
                                    _currentOutput?.Add($"Setup completed{ElapsedTime(match)}");
                                    break;

                                case UnitTestLauncher.Communication.Fail:
                                    AddFailDescription(match, $"Test failed{ElapsedTime(match)}");
                                    SetTestOutcome(match, TestResult.TestOutcome.Failed, "Test failed");
                                    break;

                                case UnitTestLauncher.Communication.CleanupFail:
                                    AddFailDescription(match, $"Cleanup for the test failed{ElapsedTime(match)}");
                                    SetTestOutcome(match, TestResult.TestOutcome.Failed, "Cleanup failed");
                                    break;

                                case UnitTestLauncher.Communication.CleanUpComplete:
                                    _currentOutput?.Add($"Cleanup completed{ElapsedTime(match)}");
                                    _currentOutput = null;
                                    _currentTestCase = null;
                                    break;

                                case UnitTestLauncher.Communication.Pass:
                                    AddFailDescription(match, $"Test passed{ElapsedTime(match)}");
                                    SetTestOutcome(match, TestResult.TestOutcome.Passed, null);
                                    break;
                            }
                            #endregion
                        }
                    }
                }
            }
        }

        private readonly Regex _parseOutput = new Regex(
@"(
    (
        (?<empty>\s+)
        |
        ((?<prefix>[^:\s\r\n]+) : (?<type>[CDM]) : (?<fqn>[^#:]+) ( \#(?<row>[0-9]+) ){0,1} : (?<time>[0-9]+) : (?<com>[A-Z0-9]+) ( : (?<msg>.+)){0,1})
        |
        (?<output>[^\r\n]+)
    )\r{0,1}\n
)
|
(?<incomplete>[^\r\n]+)", RegexOptions.Compiled | RegexOptions.IgnorePatternWhitespace | RegexOptions.IgnoreCase);

        private static string ElapsedTime(Match match)
        {
            if (long.TryParse(match.Groups["time"].Value, out long ticks))
            {
                long ms = ticks / TimeSpan.TicksPerMillisecond;
                if (ms > 0)
                {
                    return $" after {ticks / TimeSpan.TicksPerMillisecond} ms";
                }
                else
                {
                    return " after < 1 ms";
                }
            }
            return "";
        }

        private void AddFailDescription(Match match, string description)
        {
            string msg = match.Groups["msg"]?.Value;
            if (!string.IsNullOrEmpty(msg))
            {
                description = string.IsNullOrWhiteSpace(description) ? msg : $"{description}: {msg}";
            }
            if (!string.IsNullOrEmpty(description))
            {
                _currentOutput.Add(description);
            }
        }

        private void SetTestOutcome(Match match, TestResult.TestOutcome outcome, string errorMessage)
        {
            TestResult testResult = _testsInGroup[_currentTestCase];
            testResult.Outcome = outcome;
            testResult.ErrorMessage = errorMessage;
            if (long.TryParse(match.Groups["time"].Value, out long ticks))
            {
                testResult.Duration = new TimeSpan(ticks);
            }
            _currentOutput = null;
            _currentTestCase = null;
        }

        /// <summary>
        /// Complete and send the results of all tests in the group and 
        /// </summary>
        private void SendGroupResults(bool flush = false)
        {
            if (_currentGroup is null && !flush)
            {
                return;
            }


            foreach ((int selectionIndex, TestCase testCase) in _testCases.TestCases)
            {
                if (!_resultsSent.Contains(testCase) && (
                    (flush && _testClassPhase != TestClassPhases.Abort)
                    || (testCase.Group == _currentGroup && !_testsInGroup.ContainsKey(testCase))
                   ))
                {
                    var testResult = new TestResult(testCase, selectionIndex, _comPort);
                    _testsInGroup[testCase] = testResult;
                    testResult._messages.Add("Test has not been run.");
                }
            }

            if (!flush)
            {
                if (_groupSetupOutput.Count > 0 || _groupSetupOutcome != TestResult.TestOutcome.Passed)
                {
                    foreach (TestResult test in _testsInGroup.Values)
                    {
                        if (_groupSetupOutput.Count > 0)
                        {
                            test._messages.Add(string.Empty);
                            test._messages.Add("*** Setup ***");
                            test._messages.AddRange(_groupSetupOutput);
                        }
                        if (_groupSetupOutcome == TestResult.TestOutcome.Failed)
                        {
                            test.Outcome = _groupSetupOutcome;
                            test.ErrorMessage = "Setup failed";
                        }
                    }
                    _groupSetupOutput.Clear();
                    _groupSetupOutcome = TestResult.TestOutcome.Passed;
                }

                if (_groupCleanupOutput.Count > 0 || _groupCleanupOutcome != TestResult.TestOutcome.Passed)
                {
                    foreach (TestResult test in _testsInGroup.Values)
                    {
                        if (_groupCleanupOutput.Count > 0)
                        {
                            test._messages.Add(string.Empty);
                            test._messages.Add("*** Cleanup ***");
                            test._messages.AddRange(_groupCleanupOutput);
                        }
                        if (test.Outcome == TestResult.TestOutcome.Passed
                            && _groupCleanupOutcome == TestResult.TestOutcome.Failed)
                        {
                            test.Outcome = _groupCleanupOutcome;
                            test.ErrorMessage = "Cleanup failed";
                        }
                    }
                    _groupCleanupOutput.Clear();
                    _groupCleanupOutcome = TestResult.TestOutcome.Passed;
                }
            }

            if (_deploymentInformation.Count > 0)
            {
                foreach (TestResult test in _testsInGroup.Values)
                {
                    test._messages.Add(string.Empty);
                    test._messages.Add("*** Deployment ***");
                    test._messages.AddRange(_deploymentInformation);
                }
            }

            _resultsSent.UnionWith(from tr in _testsInGroup.Values
                                   select tr.TestCase);
            _testResultSink(_testsInGroup.Values);
            _testsInGroup.Clear();

            _testClassPhase = TestClassPhases.NoMansLand;
            _currentGroup = null;
            _currentOutput = null;

            IsAbortRequested();
        }

        private void SendNotExecutedResults(string deviceExecutionIsAbortedReason)
        {
            var messages = new List<string>()
            {
                "Test has not been run."
            };
            if (!string.IsNullOrWhiteSpace(deviceExecutionIsAbortedReason))
            {
                messages.Add(deviceExecutionIsAbortedReason);
            }
            if (_deploymentInformation.Count > 0)
            {
                messages.Add(string.Empty);
                messages.Add("*** Deployment ***");
                messages.AddRange(_deploymentInformation);
            }

            _testResultSink(from tc in _testCases.TestCases
                            where !_resultsSent.Contains(tc.testCase)
                            select new TestResult(tc.testCase, tc.selectionIndex, _comPort)
                            {
                                Outcome = TestResult.TestOutcome.Skipped,
                                _messages = messages
                            });
        }

        private bool IsAbortRequested()
        {
            if (_cancellationToken?.IsCancellationRequested ?? false)
            {
                lock (this)
                {
                    _lineToBeProcessed = null;
                    if (_testClassPhase != TestClassPhases.Abort)
                    {
                        _testClassPhase = TestClassPhases.Abort;
                        if (!(_parsingAborted is null))
                        {
                            try
                            {
                                _parsingAborted.Invoke();
                            }
                            catch
                            {
                            }
                        }
                    }
                }
                return true;
            }
            else
            {
                return false;
            }
        }
        #endregion
    }
}
